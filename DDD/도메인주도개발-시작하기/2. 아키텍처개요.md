# 4개의 영역

- ui (표현) layer
    - 사용자의 요청을 받아 응용 영역에 전달, 사용자에 응답하는 역할
    - 웹 어플리케이션에서 표현 영역의 사용자는 한마디로 client이다.
        - 브라우저, REST API를 호출하는 외부시스템 등.
- application (응용) layer
    - 기능을 구현한다.
    - 기능을 구현하기 위해 도메인 모델을 사용함.
    - 서비스 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다.
- domain (도메인) layer
    - 도메인 모델을 구현한다.
    - 도메인의 핵심(실제) 로직을 구현한다.
    - 만약 Order 도메인이라고 한다면 주문 총액, 할인율 적용, 주문취소 등
- infra (인프라스트럭처) layer
    - 데이터 연동을 처리한다.
    - DB, 메일, SMS, Kafka 등과 같은.

<br>

# layered architecture

- 4개의 영역을 구성할 때 많이 사용하는 아키텍처.
- 상위 계층에서 하위 계층으로 의존하게 구현한다.
- application, domain 개발시 infra에 의존적인 개발을 하는 실수를 하기 쉽다.
- application, domain 계층이 infra 계층에 의존하지 않게 하려면 ? DIP 개념을 활용한다.

<br>

# DIP - 의존 역전 원칙

- 고수준 -> 저수준 모듈 의존성을 갖게 하는것이 아닌, 저수준 -> 고수준 모듈에 의존하도록 구현하는 방식.
- 추상화된 인터페이스에 의존하게 한다면 원칙을 지킬 수 있다.
- 고수준 모듈에 의존하면 기능 확장이 용이함.
- 테스트 코드를 작성할 때 편하다.
    - 고수준 모듈을 구현하는 테스트 전용 모듈을 생성하면 되니까.
    - example -> interface `CalculateRepository`를 구현하는 `CalculateTestRepository` 를 만들어 테스트할 수 있다.
- DIP 주의사항 !!
    - 저수준 모듈에서 인터페이스를 추출하지말자.
    - `DroolsRuleEndgine` -> `RuleEngine` 기존에 존재하는 어떤 엔진에 의해 추상화된 모델을 추출하지말고,
    - `DroolsRuleEndgine` -> `RuleDiscounter` 할인율를 적용하기위해 도입한 방법중에 하나인 것이 `DroolsRuleEndgine` 인 것처럼 모데을 설계하자.

<br>

# 도메인 영역의 주요 구성요소

- entity
    - 고유 식별자를 갖는 객체로 자신의 라이프사이클을 갖는다.
- value
    - 고유 식별자를 갖지 않는 객체로 개념적으로 하나인 값을 표현한다.
- doamin service
    - 도메인 로직이 여러 엔티티와 벨류를 필요로 하면 도메인 서비스에서 로직을 구현한다.

- 엔티티와 벨류
    - 테이블 엔티티와, 도메인 엔티티는 다르다.
    - 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 제공한다.
    - 도메인 모델의 엔티티는 기능 구현을 캡슐화해서 데이터가 임의로 변경되는 것을 막는다. 무분별한 setter 구현을 지양함.

- aggregate
    - 연관된 엔티티와 벨류 객체를 하나로 묶은 것.
    - 도메인이 커질수록 개발할 도메인도 모델이 커지면서 수많은 엔티티와 벨류가 생긴다.
    - 도메인이 커질수록 매우 복잡해진다.
    - 도메인 모델이 복잡해질수록 개발자는 한개의 엔티티와 벨류에 집중하는 상황이 발생한다.
    - 애그리거트는 도메인 관련 객체를 하나로 묶는 군집이다.
    - 주문, 배송지정보, 주문자, 주문목록 등의 복잡해진 주문 도메인 모델, 벨류들을 하나로 묶어 `주문` 이라는 `상위 개념인 애그리거트` 로 만들 수 있다.
    - 주문 애그리거트는 그 중에서도 군집에 속한 객체를 관리하는 주문이라는 주문 애그리거트 루트 엔티티를 갖게할 수 있다. (가장 중요한 도메인을 루트로 만드는것임.)
    - Order(주문) 애그리거트 루트를 통해 주문이라는 도메인을 통하지 않고는 배송정보를 변경할 수 있는 방법을 제공하지 않도록 설계한다.
        - 배송지를 변경하려면 루트 엔티티인 Order를 사용하게 하므로써 Order가 구현한 도메인 로직을 항상 따르게 만든다.
    - 도메인 단위가 커지면 하위 도메인으로 나누고 하위 패키지로 구성한다.
        - 예를 들어 아래와 같이 나타낼 수 있다.
        - catalog
            - product
            - category
            - ...
        
- repository
    - 도메인 모델을 저장하거나, 조회하는 기능을 제공한다.
    - 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.
    - 도메인 모델을 사용해야 하는 코드는 repository를 통해서 도메인 객체를 구한 뒤에 도메인 객체 기능을 실행한다.
